{"meta":{"title":"99Team","subtitle":"99Team","description":"99Team 团队博客","author":"99Team","url":"https://99team.github.io"},"pages":[],"posts":[{"title":"如何写兼容浏览器和Node.js环境的Javascript代码","slug":"how-to-write-javascript-code-for-compatible-browsers-and-node","date":"2016-11-08T12:21:20.000Z","updated":"2016-11-25T09:39:22.240Z","comments":true,"path":"post/how-to-write-javascript-code-for-compatible-browsers-and-node/","link":"","permalink":"https://99team.github.io/post/how-to-write-javascript-code-for-compatible-browsers-and-node/","excerpt":"","text":"如果有打开过jQuery的源码（从1.11及以后），或者Vue.js、React.js的源码，都会在文件的前面看见这样一段代码： ( function( global, factory ) &#123; \"use strict\"; if ( typeof module === \"object\" &amp;&amp; typeof module.exports === \"object\" ) &#123; // For CommonJS and CommonJS-like environments where a proper `window` // is present, execute the factory and get jQuery. // For environments that do not have a `window` with a `document` // (such as Node.js), expose a factory as module.exports. // This accentuates the need for the creation of a real `window`. // e.g. var jQuery = require(\"jquery\")(window); // See ticket #14549 for more info. module.exports = global.document ? factory( global, true ) : function( w ) &#123; if ( !w.document ) &#123; throw new Error( \"jQuery requires a window with a document\" ); &#125; return factory( w ); &#125;; &#125; else &#123; factory( global ); &#125;// Pass this if window is not defined yet&#125; )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) &#123; //... 以上是jQuery V3.1.0的一段代码。如果自己平时写的都是在浏览器上运行的js代码，又没有接触过Node.js的，可能就不知道 ‘module.exports’ 是什么，为什么要加以判断了。如果有接触过Node，就知道 ‘module.exports’ 其实就是一个js文件的出口，相当于ES6的export。 现在。从头介绍如何写一个兼容浏览器和Node环境的js代码。假设这个js文件名为export.js。 首页，为了避免污染全局作用域，立即执行函数是必须的。这个函数的参数，就像上面的代码那样，也传入一个函数吧。 export.js代码如下： (function(factory) &#123; //判断宿主环境&#125;(function() &#123; //代码的核心&#125;)); 接下来，就是判断宿主环境。在浏览器环境下，window这个变量是无需创建，自动生成的；在Node环境下，module同理。export.js代码如下： (function(factory) &#123; if (typeof module !== 'undefined') &#123; module.exports = factory(); &#125; else &#123; factory(); &#125;&#125;(function() &#123; var vue = 30; //...&#125;)); 判断了宿主环境后，现在我们需要获得已经定义了的变量vue。在浏览器环境下，用形如 window.vue = vue; 这样的语句让vue这个变量变成全局的；而在node环境下，export.js用 return vue; 而需要用到这个变量的文件加上这么一句： var vue = require('./export.js'); 这样的语句获得vue这个变量。export.js代码如下： (function(factory) &#123; if (typeof module !== 'undefined') &#123; module.exports = factory(); &#125; else &#123; factory(); &#125;&#125;(function() &#123; var vue = 30; if (typeof window !== 'undefined') &#123; window.vue = vue; &#125; else &#123; return vue; &#125;&#125;)); 其实，在看了Vue.js的这部分代码后，发现了一个更便捷的方式，就是把vue这个全局变量放在function(factory)里面，这样，下面只要写一个return vue; 就可以了。export.js代码如下： (function(factory) &#123; if (typeof module !== 'undefined') &#123; module.exports = factory(); &#125; else &#123; window.vue = factory(); &#125;&#125;(function() &#123; var vue = 30; return vue;&#125;));","categories":[{"name":"Web开发","slug":"web开发","permalink":"https://99team.github.io/categories/web开发/"}],"tags":[],"keywords":[{"name":"Web开发","slug":"web开发","permalink":"https://99team.github.io/categories/web开发/"}]},{"title":"Yarn vs npm: 你需要知道的一切","slug":"yarn-vs-npm-everything-you-need-to-know","date":"2016-10-24T11:42:38.000Z","updated":"2016-11-25T09:39:22.240Z","comments":true,"path":"post/yarn-vs-npm-everything-you-need-to-know/","link":"","permalink":"https://99team.github.io/post/yarn-vs-npm-everything-you-need-to-know/","excerpt":"","text":"Yarn 是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。就像我们可以从官方文档了解那样，它的目的是解决这些团队使用 npm 面临的少数问题，即： 安装的时候无法保证速度/一致性 安全问题，因为 npm 安装时允许运行代码 但请不要惊慌！它并没有试图完全取代 npm。Yarn 同样是一个从 npm 注册源获取模块的新的 CLI 客户端。注册的方式不会有任何变化 —— 你同样可以正常获取与发布包。 是否每个人现在都要跳上 Yarn 这辆被大肆宣传的列车？又或者你根本没机会碰到 npm 的这些问题。本篇文章将会比较 npm 与 Yarn，最终你可以决定哪款更适合你。 Yarn vs npm: 功能差异乍一看 Yarn 与 npm 很类似，但通过引擎的对比就能察觉 Yarn 的不同。 yarn.lock 文件npm 和 Yarn 都使用 package.json 来跟踪项目的依赖，版本号并非一直准确，因为你可以定义版本号范围，这样你可以选择一个主版本和次要版本的包，但让 npm 安装最新的补丁也许可以修改一些 bug。 理想状态下使用语义化版本发布补丁不会包含大的变化，但不幸的是这必非真理。npm 的这种策略可能导致两台拥有相同 package.json 文件的机子安装了不同版本的包，这可能导致一些错误。 为了避免包版本的错误匹配，一个确定的安装版本被固定在一个锁文件中。每次模块被添加时，Yarn 就会创建（或更新）yarn.lock 文件，这样你就可以保证其它机子也安装相同版本的包，同时包含了 package.json 中定义的一系列允许的版本。 在 npm 中同样可以使用 npm shrinkwrap 命令来生成一个锁文件，这样在使用 npm install 时会在读取 package.json 前先读取这个文件，就像 Yarn 会先读取 yarn.lock 一样。这里的区别是 Yarn 总会自动更新 yarn.lock，而 npm 需要你重新操作。 yarn.lock 文档 npm shrinkwrap 文档 并行安装每当 npm 或 Yarn 需要安装一个包时，它会进行一系列的任务。在 npm 中这些任务是按包的顺序一个个执行，这意味着必须等待上一个包被完整安装才会进入下一个；Yarn 则并行的执行这些任务，提高了性能。 为了比较，我在没有使用 shrinkwrap/yarn.lock 的方式以及清理了缓存下使用 npm 与 Yarn 安装 express，总共安装了 42 个依赖。 npm: 9 s Yarn: 1.37 s 我无法相信自己的眼睛，所以重复以上步骤，但得到相同结果。接着我安装 gulp 进行测试，总共安装了 195 个依赖。 npm: 11 s Yarn: 7.81 s 似乎根据所需要安装的包的数量而有所不同，但 Yarn 依旧比较快。 清晰的输出npm 默认情况下非常冗余，例如使用 npm install 时它会递归列出所有安装的信息；而 Yarn 则一点也不冗余，当可以使用其它命令时，它适当的使用 emojis 表情来减少信息（Windows 除外）。 Yarn vs npm: CLI 的差异除了一些功能差异，Yarn 命令也存在一些区别。例如移除或修改了一些 npm 命令以及添加了几个有趣的命令。 yarn global不像 npm 添加 -g 或 --global 可以进行全局安装，Yarn 使用的是 global 前缀。不过与 npm 类似，项目依赖不推荐全局安装。 global 前缀只能用于 yarn add, yarn bin, yarn ls 和 yarn remove，除 yarn add 外，这些命令都和 npm 等效。 yarn global 文档 yarn installnpm install 命令会根据 package.json 安装依赖以及允许你添加新的模块；yarn install 仅会按 yarn.lock 或 package.json 里面的依赖顺序来安装模块。 yarn install 文档 npm install 文档 yarn add [–dev]与 npm install 类似，yarn add 允许你添加与安装模块，就像命令的名称一样，添加依赖意味着也会算定将依赖写入 package.json，类似 npm 的 --save 参数；Yarn 的 --dev 参数则是添加开发依赖，类似 npm 的 --save-dev 参数。 yarn add 文档 npm install 文档 yarn licenses [ls|generate-disclaimer]npm 没有类似命令来方便编写自己的包。yarn licenses ls 列出所有已安装包的许可协议。yarn licenses generate-disclaimer 生成包含已安装包许可协议的免责声明。某些协议要求使用者必须在项目中包含该协议，这时候该命令将变得非常好用。 yarn licenses 文档 yarn why该命令会查找依赖关系并找出为什么会将某些包安装在你的项目中。也许你明确为什么添加，也许它只是你安装包中的一个依赖，yarn why 可以帮你弄找出。 yarn why 文档 yarn upgrade该命令会根据符合 package.json 设定的规则而不是 yarn.lock 定义的确切版本来将包更新到最新版本。如果想用 npm 来实现相同目的，可以这样执行： rm -rf node_modulesnpm install 不要将该命令与 npm update 混淆，它指的是更新到自己的最新版。 yarn upgrade 文档 yarn generate-lock-entryyarn generate-lock-entry 会基于 package.json 设置的依赖生成 yarn.lock 文件，该命令与 npm shrinkwrap 类似，但应该小心使用，因为通过 yarn add 和 yarn upgrade 命令添加或更新依赖时会自动更新生成该锁文件。 yarn generate-lock-entry 文档 npm shrinkwrap 文档 稳定性与可靠性Yarn 被炒得这么火热会不会有问题？它正式发布当天就收到很多问题反馈，但官方处理问题的速度极快。这些表明社区正努力开发并修复bug。查看问题反馈的数量和类型可以发现 Yarn 在大多数用户的机子上表现的很稳定，但可能个别机子会有问题。 请注意虽然一个包管理器可能对你的项目非常重要，但它仅仅只是个工具，如果出了状况，恢复包不会困难，也并非要回归 npm。 未来也许你了解 Node.js 与 io.js 之间的历史。简单来说：io.js 是 Node.js 一些核心开发者因为项目管理上的分歧而独立出来创建的分支。不同的是，io.js 选择了开放式管理，在不到一年的时间时，两支团队达成协议，io.js 被合并回 Node.js，无论对错，它为 Node.js 带来了相当多不错的功能。 我看到 npm 与 Yarn 和它们有着类似的模式，不过 Yarn 不是分支，它解决了 npm 的一些缺陷。如果 npm 从中学到东西并邀请 Facebook，Google 或其它 Yarn 的贡献者们来一起提升 npm 不是很酷吗？虽然言之过早，但我期待它会发生。 无论哪种结果，Yarn 前途一片光明。社区得到别人对新工具的赞扬后似乎很兴奋，不幸的是，社区并没有提供路线图，所以我不确定 Yarn 是否为我们准备了其它惊喜。 结论相比 npm 的默认配置，Yarn 获得不少赞同。我们可以方便生成锁文件，安装包时非常迅速并且他们会自动添加进 package.json，同时安装与使用 Yarn 的影响也很小，你可以直接在一个项目上尝试看它是否可以工作，这使得 Yarn 可以完美替代 npm。 我绝对推荐在一个项目中尽早使用 Yarn，如果你对安装和使用新软件持谨慎态度，可以等待几个月。毕竟 npm 久经考验，它在软件开发领域也有存在的价值。 使用你正确等待 npm 完成包的安装，也许这是阅读迁移指南的最佳时刻 ;) 你怎么想呢？你是否已经在使用 Yarn？你是否将要尝试？或者这只是一个已经支离破碎的生态系统的进一步破碎？请在下面评论区留下你的观点。","categories":[{"name":"优秀译文","slug":"优秀译文","permalink":"https://99team.github.io/categories/优秀译文/"}],"tags":[],"keywords":[{"name":"优秀译文","slug":"优秀译文","permalink":"https://99team.github.io/categories/优秀译文/"}]},{"title":"使用 A-Frame 创建 3D 全景图","slug":"create-a-3d-panorama-image-with-a-frame","date":"2016-10-22T10:11:28.000Z","updated":"2016-11-25T09:39:22.240Z","comments":true,"path":"post/create-a-3d-panorama-image-with-a-frame/","link":"","permalink":"https://99team.github.io/post/create-a-3d-panorama-image-with-a-frame/","excerpt":"","text":"在 Mozilla 工作的五年里我见过许多很棒的项目。它们有的很受欢迎，有的很小众，但它们始终没有激起我与 MozVR 团队做 WebVR 和 A-Frame 项目的热情。 A-Frame 是一个致力于成为“构建 Web 虚拟现实的模块”，一个使用标记语言 或 JavaScript 在浏览器中创建 VR 体验的库。迫不急待的想使用这个项目就让我们从简单的示例开始：创建一个交互式的全景图比如这个! 查看DEMO 获取 3D 图片获取一张符合全景效果要求（公认的柱状全景格式）的 3D 图片的最简单方式就是使用手机。Dan Zajdband 的 Guri VR: 我们其它人的虚拟现实识别 APP iOS版(谷歌街景) 和安桌版(Photo Sphere 或 Cardboard Camera)。Dan 的这篇优秀文章还提到 Flickr 上的 Equirectangular 群组，如果你想简单的获取一张图片来实验的话。 使用手机来获取一张可用图像可能是个不小的挑战 – 你要保证在旋转手机的时候非常平稳来避免边缘出现锯齿。 友情提示：案例中我为 A-Frame 提供了一个样品图像，因为谷歌街景的图片大小有 10M，直接将这么大的图片展现出来就太禽兽了。如果你想看我用 GSV 应用制作的图片点击这里。这张图片的视角是我站在生活中小路上的中间。 使用 A-Frame 创建全景效果不管信不信，获取一张好的图片是最困难的部分，因为 A-Frame 可以非常容易的将图片转成 3D 可视化。A-Frame 元素可以用来创建全景效果: &lt;a-scene&gt;&lt;a-sky src=&quot;https://davidwalsh.name/demo/3d-image.jpg&quot; rotation=&quot;0 -130 0&quot;&gt;&lt;/a-sky&gt;&lt;/a-scene&gt; 以上代码是 A-Frame 常用语法（由HTML编写）；你也可以使用 JavaScript 来创建元素： // 创建场景var scene = document.createElement(&apos;a-scene&apos;);// 创建天空var sky = document.createElement(&apos;a-sky&apos;);sky.src = &apos;3d-image.jpg&apos;;sky.setAttribute(&apos;rotation&apos;, &#123; x: 0, y: -130, y: 0 &#125;);// 插入到页面中scene.appendChild(sky);document.body.appendChild(scene); rotation 属性 用来接收空间分隔 x, y, 和 z 轴旋转值；你可以使用它们来自定义视角位置。 A-Frame 可以让你点击、固定以及拖动组件来旋转图像。你也可以点击 VR 眼镜按钮在手机（cardboard maWebVR 所有网页 – 这是下一件大事！完成一个不错的装饰！）或支持 WebVR 的浏览器上以 3D 模式查看图像。 查看DEMO A-Frame 简单创建 3D！当我说获取照片是困难的部分时并没有夸张；因为使用 A-Frame 来创建 3D 全景效果时仅需要使用少量的标记语言。创建全景图是一个流行的使用案例，但该效果仅仅是 A-Frame 的冰山一角。还想了解 A-Frame 可以做什么？查看更多案例请访问 A-Frame 官网 以及 期待在所有网页中看到更多关于 WebVR 的事 – 这是下一件大事！","categories":[{"name":"优秀译文","slug":"优秀译文","permalink":"https://99team.github.io/categories/优秀译文/"}],"tags":[],"keywords":[{"name":"优秀译文","slug":"优秀译文","permalink":"https://99team.github.io/categories/优秀译文/"}]}]}